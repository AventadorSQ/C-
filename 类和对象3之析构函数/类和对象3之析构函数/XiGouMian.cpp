#include"XiGou.h"

//析构函数
#if 0
void Test()
{
	SeqList S;
}
int main()
{
	Test();
	system("pause");
	return 0;
}
#endif

//拷贝构造函数（特殊的构造函数）
//只有一个参数，该参数必须是本类类型对象的引用，传值会引发无穷递归！！！！！
//当被引用对象存在时，编译器就会自动调用来用已经存在的对象来创建新对象


//传值会引发无穷递归！！！！！why???
//因为再传值时，该形参是一个类类型对象，想要将实参拷贝到形参1中
//相当于用源对象去创建一个新对象（形参1），就会调用拷贝构造函数，一旦要调用拷贝构造函数，
//就要进行实参拷贝一份到形参2中去，由于形参2也是类类型对象，则继续调用拷贝构造函数...一直递归下去
//每一次递归都是为了创建上一次的形参（类类型对象）

//为什么传引用不会递归下去？
//因为如果是传引用，那么此时传参时，形参就是实参无须调用拷贝构造函数来给创建形参（形参和实参一个本体，形参名是实参的一个别名）

#if 0
int main()
{
	int s = 10;
	int b(s);


	Date a(2019,3,14);
	a.PrintDate();
	Date D(a);
	D.PrintDate();
	system("pause");
	return 0;
}

#endif

//3.默认拷贝构造会自动把所拷贝对象拷贝到新对象中，那么怎么有时也要自定义拷贝构造函数？
//默认拷贝构造：内存拷贝（浅拷贝）  解决办法暂放
//当一个类中要拷贝指针，那么创建的新对象就把源对象指针里面存的地址拷贝一份放进新的对象中。二者指向同一块内存空间
//在调用析构函数进行清理时先清理新对象（函数调用源对象先压栈后被释放），指针所指向空间被释放，
//此时源对象里面的指针变为野指针，再去释放源对象的指针就会崩溃。
//例：

void TestStr()
{
	String Str;
	String Str1(Str);
}

int main()
{
	TestStr();
	system("pause");
	return 0;
}